#include <iostream>
#include "sorts.h"
using namespace std;

void bubble_sort(vector <int> &arr, int arr_size)//сортировка пузырьком
	{	 
		int j, i;
		for(j = 0; j < arr_size; j++)//с каждым проходом по циклу размер массива уменьшается на 1 элемент с конца, для уменьшения количества сравнений
		{
			for(i = 0; i < arr_size - j - 1; i++)
			{
				if(arr[i] > arr[i + 1])//условие обмена элементов
				{
					swap(arr[i], arr[i + 1]);//обмен элементов расположенных в неправильном порядке	
				}
			}
		}
	}
void shell_sort(vector <int> &arr, int arr_size) 
{
		int i, 
			step = arr_size / 2;//первоначальное значение шага
		while(step >= 1)//сортировка происходит до того момента, пока шаг больше или равен 1
		{
		for(i = step; i < arr_size; i++)
			/*  начиная с элемента массива, индекс которого равен значению шага, идем по
				массиву, сравнивая элемент i и элемент с индексом i-step*/
		{
			if(arr[i] < arr[i - step])
			{
				swap(arr[i], arr[i - step]);
				if(i >= 2 * step)/*Если обмен элементов произошел,когда i было больше или равно значению
								 step*2, возвращаем i на значение i-step-1 назад для того, чтобы не 
								 пропустить недосортированные элементы.*/
				{
					i = i - step - 1;
				}
			}
		}	
		step = step / 2;/*в случае если все элементы рассположены правильно уменьшаем step в два раза*/
		}
}
void quick_sort(int l, int r, vector <int> &arr, int arr_size)
	{
		r = r - 1;
		int left = l, right = r,// значения начала и конца массива запоминаются для рекурсии
			x = (l + r) / 2;  //-индекс опорного элемента
			 
	
		while(l < r) //-условие обеспечивает выход из цикла
		{	
			while(arr[l] <= arr[x] && l != x) l++; //прохождение массива слева и справа, до нахождения элементов не удовлетворяющих условиям
			while(arr[r] >= arr[x] && r != x) r--;//-условия l!=x и r!=x не позволяют левой границе массива(l) и правой границе массива(r) проходить дальше индекса опорного элемента Х


			//далее условия arr[x] < arr[l] и arr[x] > arr[r] обеспечиваю невозможность зацикливания if-ов( проверяют упорядоченность элементов по возростанию)

			if(r == x && arr[x] < arr[l]) //-обмен значений элементов массива, когда правая граница массива равна индексу опорного элемента 
			{
				swap( arr[x] , arr[l] );
				x = l;					//-перемещение индекса опорного элемента к его значению
			}
			if(l == x && arr[x] > arr[r]) //-обмен значений элементов массива, когда левая граница массива равна индексу опорного элемента 
			{
				swap( arr[x] , arr[r] );
				x = r;					//-перемещение индекса опорного элемента к его значению
			}
			if(l < r && r != x && l != x)	//-обмен значений элементов массива, когда ни l ни r не равны индексу опорного элемента 
			{
				swap( arr[l] , arr[r] );	
			}
		
		}
	if(left < r) quick_sort(left, r - 1, arr, arr_size);//рекурсия выполняется для двух подмассивов,ни в одном из которых не задействован опорный элемент только что прошедшего ципла
	if(right > l) quick_sort(l + 1, right, arr, arr_size);
	}
/*
	Вспомогательная функция, возвращающая
	массиву свойства пирамиды
*/
void shift_down(vector <int> &arr, int arr_size)
{
	int i = 0, j;
	while (2 * i + 1 <= arr_size)
	{
		j = i;
		if (2 * i + 2 <= arr_size)
		{
			if (arr[2 * i + 1] > arr[2 * i + 2])
			{
				j = 2 * i + 1;
			}
			else
			{
				j = 2 * i + 2;
			}
		}
		else if (arr[2 * i + 1] > arr[i])
		{
			j = 2 * i + 1;
		}
		if (arr[i] < arr[j])
		{
			swap(arr[i], arr[j]);
			i = j;
		}
		else
		{
			break;
		}
	}
}

/*
	Вспомогательная функция, выстраивающая
	массив в пирамиду
*/
void heapify(vector <int> &arr, int arr_size)
{
	int i, j;
	for (i = 1; i < arr_size; i++)
	{
		if (arr[i] > arr[(i - 1) / 2])
		{
			j = i;
			while (j != 0)
			{
				if (arr[j] <= arr[(j - 1) / 2])
				{
					break;
				}
				swap(arr[j], arr[(j - 1) / 2]);
				j = (j - 1) / 2;
			}
		}
	}
}

/*
	Непосредственно сортировка
	array — массив,
	n — его размер.
*/		
void heap_sort(vector <int> &arr, int arr_size)
{
	heapify(arr, arr_size);
	int end = arr_size - 1;
	while (end > 0)
	{
		swap(arr[0], arr[end--]);
		shift_down(arr, end);
	}
}
