#include<iostream>
using namespace std;
void bubble_sort(long *arr,int n)//сортировка пузырьком
	{	 
		int j,i;
		for(j=0;j<n;j++)//с каждым проходом по циклу размер массива уменьшается на 1 элемент с конца, для уменьшения количества сравнений
		{
			for(i=0;i<n-j-1;i++)
			{
				if(arr[i]>arr[i+1])//условие обмена элементов
				{
					swap(arr[i],arr[i+1]);//обмен элементов расположенных в неправильном порядке	
				}
			}
		}
	}
void shell_sort(long *arr,int n) 
{
		int i,step;
		step=n/2;//первоначальное значение шага
		while(step>=1)//сортировка происходит до того момента, пока шаг больше или равен 1
		{
		for(i=step;i<n;i++)
			/*  начиная с элемента массива, индекс которого равен значению шага, идем по
				массиву, сравнивая элемент i и элемент с индексом i-step
			*/
		{
			if(arr[i]<arr[i-step])
			{
				swap(arr[i],arr[i-step]);
				if(i>=2*step)/*Если обмен элементов произошел,когда i было больше или равно значению
							 step*2, возвращаем i на значение i-step-1 назад для того, чтобы не 
							 пропустить недосортированные элементы.*/
				{
					i=i-step-1;
				}
			}
		}	
		step=step/2;/*в случае если все элементы рассположены правильно уменьшаем step в два раза*/
		}
}
void quick_sort(int l, int r, long *arr, int n)
	{
		
		int x=(l+r)/2;  //-индекс опорного элемента
		int left=l,right=r; //-запоминание начала и конца массива для рекурсии
	
		while(l<r) //-условие обеспечивает выход из цикла
		{	
			while(arr[l] <= arr[x] && l!=x) l++; //прохождение массива слева и справа, до нахождения элементов не удовлетворяющих условиям
			while(arr[r] >= arr[x] && r!=x) r--;//-условия l!=x и r!=x не позволяют левой границе массива(l) и правой границе массива(r) проходить дальше индекса опорного элемента Х


			//далее условия arr[x] < arr[l] и arr[x] > arr[r] обеспечиваю невозможность зацикливания if-ов( проверяют упорядоченность элементов по возростанию)

			if(r==x && arr[x] < arr[l]) //-обмен значений элементов массива, когда правая граница массива равна индексу опорного элемента 
			{
				swap( arr[x] , arr[l] );
				x = l;					//-перемещение индекса опорного элемента к его значению
			}
			if(l==x && arr[x] > arr[r]) //-обмен значений элементов массива, когда левая граница массива равна индексу опорного элемента 
			{
				swap( arr[x] , arr[r] );
				x = r;					//-перемещение индекса опорного элемента к его значению
			}
			if(l < r && r!=x && l!=x)	//-обмен значений элементов массива, когда ни l ни r не равны индексу опорного элемента 
			{
				swap( arr[l] , arr[r] );	
			}
		
		}
	if(left<r) quick_sort(left,r-1,arr,n);//рекурсия выполняется для двух подмассивов,ни в одном из которых не задействован опорный элемент только что прошедшего ципла
	if(right>l) quick_sort(l+1,right,arr,n);
	}
void heap_build (long *arr, int n) //создание пирамиды(дерева), по принципу:родитель старше либо равен потомкам. P- это адресс предка, n- кол-во элементов массива,
	//таким образом самый старший элемент будет лежать в вершине пирамиды, в arr[0]
{
	for (int i = n/2 - 1; i >= 0; i--)//идем от последнего элемента к началу
    {
		int p=i;
		while (2 * p + 1 < n) //проверка существования потомка
		{
			int x = 2 * p +1;// x  индекс  первого потомка
			if (x+1 < n && arr[x+1] >= arr[x])//если существует второй потомок и он больше первого рассматриваем его 
			{
			   x = 2 * p + 2;
			}
			if (arr[p] < arr[x]) //если самый большой из потомков больше предка, меняем их местами
			{
				swap(arr[p], arr[x]);
				p=x; //потомком становится следующий элемент
			} 
			else break;
		}
	}
}
void heap_sort(long *arr,int n)
{
	heap_build(arr,n);//создаем из массива пирамиду
	while(n>0)//пока существуют рассматриваемые элементы массива
	{
		swap(arr[n-1],arr[0]); //записываем самый старший элемент в конец массива
		n--;//рассматриваем массив без последнего элемента
		heap_build(arr,n); //опять распределяем массив по свойству	
	}
}
void Sorts(long *arr,int n, int sort)
{
	switch (sort)
	{
	case 1: bubble_sort(arr,n);
			break;
	case 2: shell_sort(arr,n);
			break;
	case 3: quick_sort(0,n,arr,n);
			break;
	case 4: heap_sort(arr,n);
			break;
	}
}