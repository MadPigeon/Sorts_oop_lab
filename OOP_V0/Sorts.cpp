#include<iostream>
using namespace std;
void bubble_sort(long *arr,int n)//сортировка пузырьком
	{	 
		int j,i;
		for(j=0;j<n;j++)//с каждым проходом по циклу размер массива уменьшается на 1 элемент с конца, для уменьшения количества сравнений
		{
			for(i=0;i<n-j-1;i++)
			{
				if(arr[i]>arr[i+1])//условие обмена элементов
				{
					swap(arr[i],arr[i+1]);//обмен элементов расположенных в неправильном порядке	
				}
			}
		}
	}
void shell_sort(long *arr,int n) 
{
		int i,step;
		step=n/2;//первоначальное значение шага
		while(step>=1)//сортировка происходит до того момента, пока шаг больше или равен 1
		{
		for(i=step;i<n;i++)
			/*  начиная с элемента массива, индекс которого равен значению шага, идем по
				массиву, сравнивая элемент i и элемент с индексом i-step
			*/
		{
			if(arr[i]<arr[i-step])
			{
				swap(arr[i],arr[i-step]);
				if(i>=2*step)/*Если обмен элементов произошел,когда i было больше или равно значению
							 step*2, возвращаем i на значение i-step-1 назад для того, чтобы не 
							 пропустить недосортированные элементы.*/
				{
					i=i-step-1;
				}
			}
		}	
		step=step/2;/*в случае если все элементы рассположены правильно уменьшаем step в два раза*/
		}
}
void quick_sort(int l, int r, long *arr, int n)
	{
		
		int x=(l+r)/2;  //-индекс опорного элемента
		int left=l,right=r; //-запоминание начала и конца массива для рекурсии
	
		while(l<r) //-условие обеспечивает выход из цикла
		{	
			while(arr[l] <= arr[x] && l!=x) l++; //прохождение массива слева и справа, до нахождения элементов не удовлетворяющих условиям
			while(arr[r] >= arr[x] && r!=x) r--;//-условия l!=x и r!=x не позволяют левой границе массива(l) и правой границе массива(r) проходить дальше индекса опорного элемента Х


			//далее условия arr[x] < arr[l] и arr[x] > arr[r] обеспечиваю невозможность зацикливания if-ов( проверяют упорядоченность элементов по возростанию)

			if(r==x && arr[x] < arr[l]) //-обмен значений элементов массива, когда правая граница массива равна индексу опорного элемента 
			{
				swap( arr[x] , arr[l] );
				x = l;					//-перемещение индекса опорного элемента к его значению
			}
			if(l==x && arr[x] > arr[r]) //-обмен значений элементов массива, когда левая граница массива равна индексу опорного элемента 
			{
				swap( arr[x] , arr[r] );
				x = r;					//-перемещение индекса опорного элемента к его значению
			}
			if(l < r && r!=x && l!=x)	//-обмен значений элементов массива, когда ни l ни r не равны индексу опорного элемента 
			{
				swap( arr[l] , arr[r] );	
			}
		
		}
	if(left<r) quick_sort(left,r-1,arr,n);//рекурсия выполняется для двух подмассивов,ни в одном из которых не задействован опорный элемент только что прошедшего ципла
	if(right>l) quick_sort(l+1,right,arr,n);
	}
/*
	Вспомогательная функция, возвращающая
	массиву свойства пирамиды
*/
void shiftDown(long *array, int n)
{
	int i = 0, j;
	while (2*i+1 <= n)
	{
		j = i;
		if (2*i+2 <= n)
		{
			if (array[2*i+1] > array[2*i+2])
			{
				j = 2*i+1;
			}
			else
			{
				j = 2*i+2;
			}
		}
		else if (array[2*i+1] > array[i])
		{
			j = 2*i+1;
		}
		if (array[i] < array[j])
		{
			swap(array[i],array[j]);
			i = j;
		}
		else
		{
			break;
		}
	}
}

/*
	Вспомогательная функция, выстраивающая
	массив в пирамиду
*/
void heapify(long *array, int n)
{
	int i,j;
	for (i = 1; i < n; i++)
	{
		if (array[i]>array[(i-1)/2])
		{
			j = i;
			while (j != 0)
			{
				if (array[j]<=array[(j-1)/2])
				{
					break;
				}
				swap(array[j],array[(j-1)/2]);
				j = (j-1)/2;
			}
		}
	}
}

/*
	Непосредственно сортировка
	array — массив,
	n — его размер.
*/		
void heap_sort(long *array, int n)
{
	heapify(array, n);
	int end = n-1;
	while (end > 0)
	{
		swap(array[0],array[end--]);
		shiftDown(array, end);
	}
}
void Sorts(long *arr,int n, int sort)
{
	switch (sort)
	{
	case 1: bubble_sort(arr,n);
			break;
	case 2: shell_sort(arr,n);
			break;
	case 3: quick_sort(0,n,arr,n);
			break;
	case 4: heap_sort(arr,n);
			break;
	}
}